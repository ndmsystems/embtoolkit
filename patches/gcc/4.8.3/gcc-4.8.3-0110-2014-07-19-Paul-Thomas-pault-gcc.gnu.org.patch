From d8e66c3b3643d3b2526a08246e2600c70325acef Mon Sep 17 00:00:00 2001
From: pault <pault@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Sat, 19 Jul 2014 14:31:06 +0000
Subject: [PATCH 110/134] 2014-07-19  Paul Thomas  <pault@gcc.gnu.org>

	PR fortran/61780
	* dependency.c (gfc_dep_resolver): Index the 'reverse' array so
	that elements are skipped. This then correctly aligns 'reverse'
	with the scalarizer loops.

2014-07-19  Paul Thomas  <pault@gcc.gnu.org>

	PR fortran/61780
	* gfortran.dg/dependency_44.f90 : New test


git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_8-branch@212847 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/fortran/ChangeLog                       |  8 +++++++
 gcc/fortran/dependency.c                    | 31 ++++++++++++++++---------
 gcc/testsuite/ChangeLog                     |  6 +++++
 gcc/testsuite/gfortran.dg/dependency_44.f90 | 36 +++++++++++++++++++++++++++++
 4 files changed, 70 insertions(+), 11 deletions(-)
 create mode 100644 gcc/testsuite/gfortran.dg/dependency_44.f90

diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
index c0ab457..a21b5db 100644
--- a/gcc/fortran/ChangeLog
+++ b/gcc/fortran/ChangeLog
@@ -1,3 +1,11 @@
+2014-07-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/61780
+	* dependency.c (gfc_dep_resolver): Index the 'reverse' array so
+	that elements are skipped. This then correctly aligns 'reverse'
+	with the scalarizer loops.
+
 2014-07-08  Paul Thomas  <pault@gcc.gnu.org>
 
 	PR fortran/61459
diff --git a/gcc/fortran/dependency.c b/gcc/fortran/dependency.c
index e58bd22..3924905 100644
--- a/gcc/fortran/dependency.c
+++ b/gcc/fortran/dependency.c
@@ -1779,6 +1779,7 @@ int
 gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)
 {
   int n;
+  int m;
   gfc_dependency fin_dep;
   gfc_dependency this_dep;
 
@@ -1828,6 +1829,8 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)
 	      break;
 	    }
 
+	  /* Index for the reverse array.  */
+	  m = -1;
 	  for (n=0; n < lref->u.ar.dimen; n++)
 	    {
 	      /* Assume dependency when either of array reference is vector
@@ -1862,38 +1865,44 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)
 		 The ability to reverse or not is set by previous conditions
 		 in this dimension.  If reversal is not activated, the
 		 value GFC_DEP_BACKWARD is reset to GFC_DEP_OVERLAP.  */
+
+	      /* Get the indexing right for the scalarizing loop. If this
+		 is an element, there is no corresponding loop.  */
+	      if (lref->u.ar.dimen_type[n] != DIMEN_ELEMENT)
+		m++;
+
 	      if (rref->u.ar.dimen_type[n] == DIMEN_RANGE
 		    && lref->u.ar.dimen_type[n] == DIMEN_RANGE)
 		{
 		  /* Set reverse if backward dependence and not inhibited.  */
-		  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)
-		    reverse[n] = (this_dep == GFC_DEP_BACKWARD) ?
-			         GFC_REVERSE_SET : reverse[n];
+		  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)
+		    reverse[m] = (this_dep == GFC_DEP_BACKWARD) ?
+			         GFC_REVERSE_SET : reverse[m];
 
 		  /* Set forward if forward dependence and not inhibited.  */
-		  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)
-		    reverse[n] = (this_dep == GFC_DEP_FORWARD) ?
-			         GFC_FORWARD_SET : reverse[n];
+		  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)
+		    reverse[m] = (this_dep == GFC_DEP_FORWARD) ?
+			         GFC_FORWARD_SET : reverse[m];
 
 		  /* Flag up overlap if dependence not compatible with
 		     the overall state of the expression.  */
-		  if (reverse && reverse[n] == GFC_REVERSE_SET
+		  if (reverse && reverse[m] == GFC_REVERSE_SET
 		        && this_dep == GFC_DEP_FORWARD)
 		    {
-	              reverse[n] = GFC_INHIBIT_REVERSE;
+	              reverse[m] = GFC_INHIBIT_REVERSE;
 		      this_dep = GFC_DEP_OVERLAP;
 		    }
-		  else if (reverse && reverse[n] == GFC_FORWARD_SET
+		  else if (reverse && reverse[m] == GFC_FORWARD_SET
 		        && this_dep == GFC_DEP_BACKWARD)
 		    {
-	              reverse[n] = GFC_INHIBIT_REVERSE;
+	              reverse[m] = GFC_INHIBIT_REVERSE;
 		      this_dep = GFC_DEP_OVERLAP;
 		    }
 
 		  /* If no intention of reversing or reversing is explicitly
 		     inhibited, convert backward dependence to overlap.  */
 		  if ((reverse == NULL && this_dep == GFC_DEP_BACKWARD)
-		      || (reverse != NULL && reverse[n] == GFC_INHIBIT_REVERSE))
+		      || (reverse != NULL && reverse[m] == GFC_INHIBIT_REVERSE))
 		    this_dep = GFC_DEP_OVERLAP;
 		}
 
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index c35517d..0c120b6 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,9 @@
+2014-07-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk.
+	PR fortran/61780
+	* gfortran.dg/dependency_44.f90 : New test
+
 2014-07-10  Eric Botcazou  <ebotcazou@adacore.com>
 
 	* gnat.dg/opt39.adb: New test.
diff --git a/gcc/testsuite/gfortran.dg/dependency_44.f90 b/gcc/testsuite/gfortran.dg/dependency_44.f90
new file mode 100644
index 0000000..ebfeec6
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/dependency_44.f90
@@ -0,0 +1,36 @@
+! { dg-do run }
+! Tests fix for PR61780 in which the loop reversal mechanism was
+! not accounting for the first index being an element so that no
+! loop in this dimension is created.
+!
+! Contributed by Manfred Tietze on clf.
+!
+program prgm3
+    implicit none
+    integer, parameter :: n = 10, k = 3
+    integer :: i, j
+    integer, dimension(n,n) :: y
+    integer :: res1(n), res2(n)
+
+1   format(10i5)
+
+!initialize
+    do i=1,n
+        do j=1,n
+            y(i,j) = n*i + j
+        end do
+    end do
+    res2 = y(k,:)
+
+!shift right
+    y(k,4:n) = y(k,3:n-1)
+    y(k,3) = 0
+    res1 = y(k,:)
+    y(k,:) = res2
+    y(k,n:4:-1) = y(k,n-1:3:-1)
+    y(k,3) = 0
+    res2 = y(k,:)
+!    print *, res1
+!    print *, res2
+    if (any(res1 /= res2)) call abort ()
+end program prgm3
-- 
1.8.5.5

