From 441c86388c9983158f6e8eb66d2dd6346810e5e7 Mon Sep 17 00:00:00 2001
From: jason <jason@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Mon, 30 Jun 2014 17:30:22 +0000
Subject: [PATCH 079/134] 	PR c++/61539 	* pt.c (unify_one_argument):
 Type/expression mismatch just causes 	deduction failure.

git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_8-branch@212161 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/cp/ChangeLog                         |  4 +++
 gcc/cp/pt.c                              |  5 ++--
 gcc/testsuite/g++.dg/cpp0x/variadic160.C | 49 ++++++++++++++++++++++++++++++++
 3 files changed, 56 insertions(+), 2 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/cpp0x/variadic160.C

diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 80c7fd8..d67a63e 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,5 +1,9 @@
 2014-06-30  Jason Merrill  <jason@redhat.com>
 
+	PR c++/61539
+	* pt.c (unify_one_argument): Type/expression mismatch just causes
+	deduction failure.
+
 	PR c++/61500
 	* tree.c (lvalue_kind): Handle MEMBER_REF and DOTSTAR_EXPR.
 
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index a4e1a59..3ddd4b8 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -15503,8 +15503,9 @@ unify_one_argument (tree tparms, tree targs, tree parm, tree arg,
 	maybe_adjust_types_for_deduction (strict, &parm, &arg, arg_expr);
     }
   else
-    gcc_assert ((TYPE_P (parm) || TREE_CODE (parm) == TEMPLATE_DECL)
-		== (TYPE_P (arg) || TREE_CODE (arg) == TEMPLATE_DECL));
+    if ((TYPE_P (parm) || TREE_CODE (parm) == TEMPLATE_DECL)
+	!= (TYPE_P (arg) || TREE_CODE (arg) == TEMPLATE_DECL))
+      return unify_template_argument_mismatch (explain_p, parm, arg);
 
   /* For deduction from an init-list we need the actual list.  */
   if (arg_expr && BRACE_ENCLOSED_INITIALIZER_P (arg_expr))
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic160.C b/gcc/testsuite/g++.dg/cpp0x/variadic160.C
new file mode 100644
index 0000000..20fcd5b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic160.C
@@ -0,0 +1,49 @@
+// PR c++/61539
+// { dg-do compile { target c++11 } }
+
+template <typename _CharT> class A;
+template <typename> class B;
+template <class charT> class C;
+template <> class C<char>
+{
+  virtual void xparse (int &, const B<A<char> > &) const;
+};
+template <class T, class charT = char> class G : C<charT>
+{
+public:
+  G (void *) {}
+  void default_value (const T &);
+  void xparse (int &, const B<A<charT> > &) const;
+};
+template <class T, class charT>
+void validate (int &, const B<A<charT> > &, T *, int);
+template <class T, class charT>
+void G<T, charT>::xparse (int &p1, const B<A<charT> > &p2) const
+{
+  validate (p1, p2, (T *)0, 0);
+}
+template <class T> G<T> *value (T *) { return new G<T>(0); }
+namespace Eigen
+{
+template <typename T> struct D;
+template <typename, int, int, int = 0, int = 0, int = 0 > class F;
+template <typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows,
+          int _MaxCols>
+struct D<F<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >
+{
+  typedef _Scalar Scalar;
+};
+template <typename, int, int, int, int, int _MaxCols> class F
+{
+public:
+  typedef typename Eigen::D<F>::Scalar Scalar;
+  F (const Scalar &, const Scalar &, const Scalar &);
+};
+template <class... T>
+void validate (int &, const B<A<char> > &, Eigen::F<T...> *);
+}
+int main (int, char *[])
+{
+  Eigen::F<double, 3, 1> a (0, 0, 0);
+  value (&a)->default_value (Eigen::F<double, 3, 1>(0, 0, 0));
+}
-- 
1.8.5.5

